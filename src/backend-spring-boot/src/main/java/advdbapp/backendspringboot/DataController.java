package advdbapp.backendspringboot;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import advdbapp.backendspringboot.persistence.model.Data;
import advdbapp.backendspringboot.persistence.repo.DataRepository;

@CrossOrigin(origins = "http://localhost:3000")
@Controller // This means that this class is a Controller
@RequestMapping(path="/data") // This means URL's start with /data (after Application path)
public class DataController {

    @Autowired 
    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private DataRepository dataRepository;


    private String diagramType;

    private HashSet<String> ids = new HashSet<String>();
    private HashSet<String> years = new HashSet<String>();
    private HashSet<String> countries = new HashSet<String>();

    private ArrayList<String> totalIndexes = new ArrayList<String>();

    // in the end the diagrams will get their data from .cvs files
    // that we will create 
    private CsvCreator csvCreator= new CsvCreator();
    private String lineCsv = "";
    private String barCsv = "";
    private String scatterCsv = "";


    private void reset() {
        diagramType = "";
        ids.clear();
        years.clear();
        countries.clear();
        totalIndexes.clear();
        lineCsv = "";
        barCsv = "";
        scatterCsv = "";
    }

    // the diagrams just have to use the corresponding url to get the data

    @CrossOrigin(origins = "*")
    @RequestMapping(value = "lineResult.csv")
    public void dataForLine(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(lineCsv);
    }
    
    @CrossOrigin(origins = "*")
    @RequestMapping(value = "barResult.csv")
    public void dataForBar(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(barCsv);
    }

    @CrossOrigin(origins = "*")
    @RequestMapping(value = "scatterResult.csv")
    public void dataForScatter(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(scatterCsv);
    }

    
    
    @GetMapping(path="y/{years}")
    public @ResponseBody void getFinalIds(@PathVariable String years) {
        HashSet<String> tempIds = new HashSet<String>();
        int minYear = Integer.parseInt(years.split("-")[0]);
        int maxYear = Integer.parseInt(years.split("-")[1]);
        
        for (String id : ids) {
            Optional<Data> optionalEntity = findById(id);
            Data dataEntity = optionalEntity.get();
            int dataEntityYear = Integer.parseInt(dataEntity.getYear());

            if (dataEntityYear >= minYear && dataEntityYear <= maxYear) {
                tempIds.add(id);
            }
        }
        ids = tempIds;

        createFinalData();        
    }

    private Optional<Data> findById(String id) {
        long newId=Integer.parseInt(id);
        return dataRepository.findById(newId);
    }

    private void createFinalData() {
        years.clear();
        countries.clear();
        List<String> sortedIds = new ArrayList<String>(ids);
        Collections.sort(sortedIds);

        HashMap<String, String> csvData = new HashMap<String, String>();

        for (String id : sortedIds) {
            Optional<Data> optionalEntity = findById(id);
            Data dataEntity = optionalEntity.get();

            String year = dataEntity.getYear();
            String country = dataEntity.getCountry();

            years.add(year);
            countries.add(country);
            

            for (String index : totalIndexes) {
                String key = year + country + index;
                String value = getIndexFromData(dataEntity, index);
                csvData.put(key, value);
                
            }
        }
        List<String> sortedYears = new ArrayList<String>(years);
        Collections.sort(sortedYears);

        List<String> sortedIndexes = new ArrayList<String>(totalIndexes);
        Collections.sort(sortedIndexes);

        List<String> sortedCountries = new ArrayList<String>(countries);
        Collections.sort(sortedCountries);

        csvCreator.init(csvData, sortedYears, sortedIndexes, sortedCountries);
        

        if (diagramType.equals("line")) {
            lineCsv = csvCreator.lineCsv();
        }
        else if (diagramType.equals("bar")) {
            barCsv = csvCreator.barCsv();
        }
        else if (diagramType.equals("scatter")) {
            scatterCsv = csvCreator.scatterCsv();
        }
    }
    
    
    private String getIndexFromData(Data dataEntity, String index) {
        if (index.equals("CoalConsumption")) {
            return dataEntity.getCoalConsumptionTotal();
        }
        else if (index.equals("ElectricityGeneration")) {
            return dataEntity.getElectricityGenerationTotal();
        }
        else if (index.equals("EnergyProduction")) {
            return dataEntity.getEnergyProductionTotal();
        }
        else if (index.equals("HydroPowerGeneration")) {
            return dataEntity.getHydroPowerGenerationTotal();
        }
        else if (index.equals("NaturalGasProduction")) {
            return dataEntity.getNaturalGasProductionTotal();
        }
        else if (index.equals("NaturalGasProvedReserves")) {
            return dataEntity.getNaturalGasProvedReservesTotal();
        }
        else if (index.equals("NuclearPowerGeneration")) {
            return dataEntity.getNuclearPowerGenerationTotal();
        }
        else if (index.equals("OilConsumption")) {
            return dataEntity.getOilConsumptionTotal();
        }
        else if (index.equals("OilProduction")) {
            return dataEntity.getOilProductionTotal();
        }
        else if (index.equals("OilProvedReserves")) {
            return dataEntity.getOilProvedReservesTotal();
        }
        else if (index.equals("ResidentialElectricityUse")) {
            return dataEntity.getResidentialElectricityUseTotal();
        }
        else if (index.equals("HappinessScore")) {
            return dataEntity.getHapiscoreWhr();
        }
        else if (index.equals("HumanDevelopmentIndex")) {
            return dataEntity.getHdiHumanDevelopmentIndex();
        }
        else if (index.equals("GDP")) {
            return dataEntity.getIncomePerPersonGdppercapitaPppInflationAdjusted();
        }
        else if (index.equals("InequalityIndexGini")) {
            return dataEntity.getInequalityIndexGini();
        }
        else if (index.equals("TotalPopulation")) {
            return dataEntity.getPopulationTotal();
        }
        else {
            return null;
        }
    }

    
    @GetMapping(path="c/{countries}")
    public @ResponseBody Iterable<String> getYears(@PathVariable String countries) {
        int countryCounter = 0;
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempYears = new HashSet<String>();

        for (String country : countries.split("-")) {
            for (Data result : findByCountry(country)) {
                String resultId = String.valueOf(result.getId());
                String year = result.getYear();

                if (ids.contains(resultId)) {
                    if (countryCounter == 0) {
                        tempIds.add(resultId);
                        years.add(year);
                    }
                    else {
                        tempIds.add(resultId);
                        tempYears.add(year);
                    }
                }
            }
            if (countryCounter >= 1) {
                years.retainAll(tempYears);
                tempYears.clear();
            }
            countryCounter += 1;
        }
        ids = tempIds;
        List<String> list = new ArrayList<String>(years);
        Collections.sort(list);
        return list;   
    }

    private Iterable<Data> findByCountry(String country) {
        return dataRepository.findByCountry(country);
    }
    
    
    
    @GetMapping(path="i/{indexes}")
    public @ResponseBody Iterable<String> getCountries(@PathVariable String indexes) {
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempCountries = new HashSet<String>();
        int indexCounter = 0;

        for (String index : indexes.split("-")) {
            totalIndexes.add(index);
            for (String result : findByIndex(index)) {
                String[] splittedResult = result.split(",");
                String id = splittedResult[0];
                String country = splittedResult[1];
                if (indexCounter == 0) {
                    ids.add(id);
                    countries.add(country);
                }
                else {
                    tempIds.add(id);
                    tempCountries.add(country);
                }
            }
            if (indexCounter >= 1) {
                ids.retainAll(tempIds);
                countries.retainAll(tempCountries);
                tempIds.clear();
                tempCountries.clear();
            }
            indexCounter += 1;
        }
        List<String> list = new ArrayList<String>(countries);
        Collections.sort(list);
        return list;
    }

    private Iterable<String> findByIndex(String index) {
        if (index.equals("CoalConsumption")) {
            return dataRepository.coalConsumptionTotalCountryQuery();
        }
        else if (index.equals("ElectricityGeneration")) {
            return dataRepository.electricityGenerationTotalCountryQuery();
        }
        else if (index.equals("EnergyProduction")) {
            return dataRepository.energyProductionTotalQuery();
        }
        else if (index.equals("HydroPowerGeneration")) {
            return dataRepository.hydroPowerGenerationTotalQuery();
        }
        else if (index.equals("NaturalGasProduction")) {
            return dataRepository.naturalGasProductionTotalQuery();
        }
        else if (index.equals("NaturalGasProvedReserves")) {
            return dataRepository.naturalGasProvedReservesTotalQuery();
        }
        else if (index.equals("NuclearPowerGeneration")) {
            return dataRepository.nuclearPowerGenerationTotalQuery();
        }
        else if (index.equals("OilConsumption")) {
            return dataRepository.oilConsumptionTotalQuery();
        }
        else if (index.equals("OilProduction")) {
            return dataRepository.oilProductionTotalQuery();
        }
        else if (index.equals("OilProvedReserves")) {
            return dataRepository.oilProvedReservesTotalQuery();
        }
        else if (index.equals("ResidentialElectricityUse")) {
            return dataRepository.residentialElectricityUseTotalQuery();
        }
        else if (index.equals("HappinessScore")) {
            return dataRepository.hapiscoreWhrQuery();
        }
        else if (index.equals("HumanDevelopmentIndex")) {
            return dataRepository.hdiHumanDevelopmentIndexQuery();
        }
        else if (index.equals("GDP")) {
            return dataRepository.incomePerPersonGdppercapitaPppInflationAdjustedQuery();
        }
        else if (index.equals("InequalityIndexGini")) {
            return dataRepository.inequalityIndexGiniQuery();
        }
        else if (index.equals("TotalPopulation")) {
            return dataRepository.populationTotalQuery();
        }
        else {
            return null;
        }
    }


    @GetMapping(path="d/{diagramType}")
    public @ResponseBody void getDiagramType(@PathVariable String diagramType) {
        reset();
        this.diagramType = diagramType;
    }
}
