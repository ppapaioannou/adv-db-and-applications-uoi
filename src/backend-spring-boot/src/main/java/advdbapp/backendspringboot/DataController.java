package advdbapp.backendspringboot;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import advdbapp.backendspringboot.persistence.model.Data;
import advdbapp.backendspringboot.persistence.repo.DataRepository;

/*
                    --Data Controller--

The idea behind this controller is to use user input to get data
and then prune that data, keeping only the useful data so in the 
end it can create csv files that will be self-hosted 
and the diagram library can then use that url as data for the plotting


*/

@CrossOrigin(origins = "http://localhost:3000") // for our frontend
@Controller
@RequestMapping(path="/data") // This means URL's start with /data (after Application path)
public class DataController {

    @Autowired 
    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private DataRepository dataRepository;


    private String diagramType;

    // sets with information that will be collected by the user choises
    private HashSet<String> ids = new HashSet<String>();
    private HashSet<String> years = new HashSet<String>();
    private HashSet<String> countries = new HashSet<String>();

    // keep track of all the indexes that were choosen to use them later for the csv
    private ArrayList<String> totalIndexes = new ArrayList<String>();

    // in the end the diagrams will get their data from .cvs files that we will create 
    private CsvCreator csvCreator= new CsvCreator();
    private String lineCsv = "";
    private String barCsv = "";
    private String scatterCsv = "";


    @GetMapping(path="d/{diagramType}")
    public @ResponseBody void getDiagramType(@PathVariable String diagramType) {
        // when a new diagram type is selected reset everything so that we start fresh 
        reset();
        this.diagramType = diagramType;
    }

    private void reset() {
        diagramType = "";
        ids.clear();
        years.clear();
        countries.clear();
        totalIndexes.clear();
        lineCsv = "";
        barCsv = "";
        scatterCsv = "";
    }


    // first get a set of countries for the choosen index
    // not all countries have measurements for the same index
    // if the are more than one index we need to get the intersection
    @GetMapping(path="i/{indexes}")
    public @ResponseBody Iterable<String> getCountries(@PathVariable String indexes) {
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempCountries = new HashSet<String>();
        int indexCounter = 0;

        // we will pass the arguments seperated by '-'
        for (String index : indexes.split("-")) {
            totalIndexes.add(index);
            for (String result : findByIndex(index)) {
                String[] splittedResult = result.split(",");
                String id = splittedResult[0];
                String country = splittedResult[1];
                if (indexCounter == 0) {
                    // store results for now
                    ids.add(id);
                    countries.add(country);
                }
                else {
                    // store second index results on another set
                    tempIds.add(id);
                    tempCountries.add(country);
                }
            }
            if (indexCounter >= 1) {
                // if we have two or more indexes get the intersection
                // of those two sets to only have same countries in the end
                ids.retainAll(tempIds);
                countries.retainAll(tempCountries);
                tempIds.clear();
                tempCountries.clear();
            }
            indexCounter += 1;
        }
        List<String> list = new ArrayList<String>(countries);
        Collections.sort(list);
        return list;
    }

    // this calls an sql query for each index
    private Iterable<String> findByIndex(String index) {
        if (index.equals("CoalConsumption")) {
            return dataRepository.coalConsumptionTotalCountryQuery();
        }
        else if (index.equals("ElectricityGeneration")) {
            return dataRepository.electricityGenerationTotalCountryQuery();
        }
        else if (index.equals("EnergyProduction")) {
            return dataRepository.energyProductionTotalQuery();
        }
        else if (index.equals("HydroPowerGeneration")) {
            return dataRepository.hydroPowerGenerationTotalQuery();
        }
        else if (index.equals("NaturalGasProduction")) {
            return dataRepository.naturalGasProductionTotalQuery();
        }
        else if (index.equals("NaturalGasProvedReserves")) {
            return dataRepository.naturalGasProvedReservesTotalQuery();
        }
        else if (index.equals("NuclearPowerGeneration")) {
            return dataRepository.nuclearPowerGenerationTotalQuery();
        }
        else if (index.equals("OilConsumption")) {
            return dataRepository.oilConsumptionTotalQuery();
        }
        else if (index.equals("OilProduction")) {
            return dataRepository.oilProductionTotalQuery();
        }
        else if (index.equals("OilProvedReserves")) {
            return dataRepository.oilProvedReservesTotalQuery();
        }
        else if (index.equals("ResidentialElectricityUse")) {
            return dataRepository.residentialElectricityUseTotalQuery();
        }
        else if (index.equals("HappinessScore")) {
            return dataRepository.hapiscoreWhrQuery();
        }
        else if (index.equals("HumanDevelopmentIndex")) {
            return dataRepository.hdiHumanDevelopmentIndexQuery();
        }
        else if (index.equals("GDP")) {
            return dataRepository.incomePerPersonGdppercapitaPppInflationAdjustedQuery();
        }
        else if (index.equals("InequalityIndexGini")) {
            return dataRepository.inequalityIndexGiniQuery();
        }
        else if (index.equals("TotalPopulation")) {
            return dataRepository.populationTotalQuery();
        }
        else {
            return null;
        }
    }


    // this time from the choosen countries get the years that are the same
    @GetMapping(path="c/{countries}")
    public @ResponseBody Iterable<String> getYears(@PathVariable String countries) {
        int countryCounter = 0;
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempYears = new HashSet<String>();
         // like before the arguments are seperated by '-'
        for (String country : countries.split("-")) {
            for (Data result : findByCountry(country)) {
                String resultId = String.valueOf(result.getId());
                String year = result.getYear();

                // first get all the ids for that country
                // and then only keep the ids that are inside
                // the set we created from the previous query
                if (ids.contains(resultId)) {
                    if (countryCounter == 0) {
                        tempIds.add(resultId);
                        years.add(year);
                    }
                    else {
                        tempIds.add(resultId);
                        tempYears.add(year);
                    }
                }
            }
            if (countryCounter >= 1) {
                // like before keep the intersection
                years.retainAll(tempYears);
                tempYears.clear();
            }
            countryCounter += 1;
        }
        ids = tempIds;
        List<String> list = new ArrayList<String>(years);
        Collections.sort(list);
        return list;   
    }

    private Iterable<Data> findByCountry(String country) {
        return dataRepository.findByCountry(country);
    }


    // final critiria for the ids that we keep
    // we did all this process to prune our results
    // and keep only values tha have measurements to plot
    @GetMapping(path="y/{years}")
    public @ResponseBody void getFinalData(@PathVariable String years) {
        HashSet<String> tempIds = new HashSet<String>();
        int minYear = Integer.parseInt(years.split("-")[0]);
        int maxYear = Integer.parseInt(years.split("-")[1]);
        
        for (String id : ids) {
            Optional<Data> optionalEntity = findById(id);
            Data dataEntity = optionalEntity.get();
            int dataEntityYear = Integer.parseInt(dataEntity.getYear());

            
            if (dataEntityYear >= minYear && dataEntityYear <= maxYear) {
                tempIds.add(id);
            }
        }
        ids = tempIds;

        // with this call we create the final csv that the d3 library will use
        createFinalData(); 
    }

    private Optional<Data> findById(String id) {
        long newId=Integer.parseInt(id);
        return dataRepository.findById(newId);
    }

    // right now we need to create a dictionary
    // that will store all our measurements for each data entry
    // after that we can use this dictionary to create to .csv file
    private void createFinalData() {
        years.clear();
        countries.clear();
        List<String> sortedIds = new ArrayList<String>(ids);
        Collections.sort(sortedIds);

        HashMap<String, String> csvData = new HashMap<String, String>();

        for (String id : sortedIds) {
            Optional<Data> optionalEntity = findById(id);
            Data dataEntity = optionalEntity.get();

            String year = dataEntity.getYear();
            String country = dataEntity.getCountry();

            years.add(year);
            countries.add(country);
            
            for (String index : totalIndexes) {
                String key = year + country + index;
                String value = getIndexFromData(dataEntity, index);
                csvData.put(key, value);
                
            }
        }
        List<String> sortedYears = new ArrayList<String>(years);
        Collections.sort(sortedYears);

        List<String> sortedIndexes = new ArrayList<String>(totalIndexes);
        Collections.sort(sortedIndexes);

        List<String> sortedCountries = new ArrayList<String>(countries);
        Collections.sort(sortedCountries);


        csvCreator.init(csvData, sortedYears, sortedIndexes, sortedCountries);
        
        if (diagramType.equals("line")) {
            lineCsv = csvCreator.lineCsv();
        }
        else if (diagramType.equals("bar")) {
            barCsv = csvCreator.barCsv();
        }
        else if (diagramType.equals("scatter")) {
            scatterCsv = csvCreator.scatterCsv();
        }
    }
    
    private String getIndexFromData(Data dataEntity, String index) {
        if (index.equals("CoalConsumption")) {
            return dataEntity.getCoalConsumptionTotal();
        }
        else if (index.equals("ElectricityGeneration")) {
            return dataEntity.getElectricityGenerationTotal();
        }
        else if (index.equals("EnergyProduction")) {
            return dataEntity.getEnergyProductionTotal();
        }
        else if (index.equals("HydroPowerGeneration")) {
            return dataEntity.getHydroPowerGenerationTotal();
        }
        else if (index.equals("NaturalGasProduction")) {
            return dataEntity.getNaturalGasProductionTotal();
        }
        else if (index.equals("NaturalGasProvedReserves")) {
            return dataEntity.getNaturalGasProvedReservesTotal();
        }
        else if (index.equals("NuclearPowerGeneration")) {
            return dataEntity.getNuclearPowerGenerationTotal();
        }
        else if (index.equals("OilConsumption")) {
            return dataEntity.getOilConsumptionTotal();
        }
        else if (index.equals("OilProduction")) {
            return dataEntity.getOilProductionTotal();
        }
        else if (index.equals("OilProvedReserves")) {
            return dataEntity.getOilProvedReservesTotal();
        }
        else if (index.equals("ResidentialElectricityUse")) {
            return dataEntity.getResidentialElectricityUseTotal();
        }
        else if (index.equals("HappinessScore")) {
            return dataEntity.getHapiscoreWhr();
        }
        else if (index.equals("HumanDevelopmentIndex")) {
            return dataEntity.getHdiHumanDevelopmentIndex();
        }
        else if (index.equals("GDP")) {
            return dataEntity.getIncomePerPersonGdppercapitaPppInflationAdjusted();
        }
        else if (index.equals("InequalityIndexGini")) {
            return dataEntity.getInequalityIndexGini();
        }
        else if (index.equals("TotalPopulation")) {
            return dataEntity.getPopulationTotal();
        }
        else {
            return null;
        }
    }


    // the d3 diagrams just have to use the corresponding url to get the data
    @CrossOrigin(origins = "*")
    @RequestMapping(value = "/plot/lineResult.csv")
    public void dataForLine(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(lineCsv);
    }
    
    @CrossOrigin(origins = "*")
    @RequestMapping(value = "/plot/barResult.csv")
    public void dataForBar(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(barCsv);
    }

    @CrossOrigin(origins = "*")
    @RequestMapping(value = "/plot/scatterResult.csv")
    public void dataForScatter(HttpServletResponse response) throws IOException {        
        response.setContentType("text/plain; charset=utf-8");
        response.getWriter().print(scatterCsv);
    }

}
