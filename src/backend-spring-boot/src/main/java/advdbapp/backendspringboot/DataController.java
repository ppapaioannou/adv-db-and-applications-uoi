package advdbapp.backendspringboot;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import advdbapp.backendspringboot.persistence.model.Data;
import advdbapp.backendspringboot.persistence.repo.DataRepository;

@CrossOrigin(origins = "http://localhost:3000")
@Controller // This means that this class is a Controller
@RequestMapping(path="/data") // This means URL's start with /data (after Application path)
public class DataController {

    @Autowired 
    // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private DataRepository dataRepository;


    private HashSet<String> ids = new HashSet<String>();
    private HashSet<String> years = new HashSet<String>();
    private HashSet<String> countries = new HashSet<String>();

    
    /*
    @GetMapping("/final")
    public @ResponseBody Iterable<Data> find() {
        ArrayList<Data> t = new ArrayList<Data>();
        for (String id : ids) {
            Optional<Data> optionalEntity =  findById(id);
            Data dataEntity = optionalEntity.get();
            t.add(dataEntity);
        }
        return t;
    }
    */


    @GetMapping(path="y/{years}")
    public void getFinalIds(@PathVariable String years) {
        HashSet<String> tempIds = new HashSet<String>();
        int minYear = Integer.parseInt(years.split("-")[0]);
        int maxYear = Integer.parseInt(years.split("-")[1]);
        

        for (String id : ids) {
            Optional<Data> optionalEntity = findById(id);
            Data dataEntity = optionalEntity.get();
            int dataEntityYear = Integer.parseInt(dataEntity.getYear());

            if (dataEntityYear >= minYear && dataEntityYear <= maxYear) {
                tempIds.add(id);
            }
        }
        ids = tempIds;

        for (String id : ids) {
            System.out.println(id);
        }
        
    }

    private Optional<Data> findById(String id) {
        long newId=Integer.parseInt(id);
        return dataRepository.findById(newId);
    }

    
    @GetMapping(path="c/{countries}")
    public @ResponseBody Iterable<String> getYears(@PathVariable String countries) {
        int countryCounter = 0;
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempYears = new HashSet<String>();

        for (String country : countries.split("-")) {
            for (Data result : findByCountry(country)) {
                String resultId = String.valueOf(result.getId());
                String year = result.getYear();

                if (ids.contains(resultId)) {
                    if (countryCounter == 0) {
                        tempIds.add(resultId);
                        years.add(year);
                    }
                    else {
                        tempIds.add(resultId);
                        tempYears.add(year);
                    }
                }
            }
            if (countryCounter >= 1) {
                years.retainAll(tempYears);
                tempYears.clear();
            }
            countryCounter += 1;
        }
        ids = tempIds;
        List<String> list = new ArrayList<String>(years);
        Collections.sort(list);
        //String[] years = {String.valueOf(list.get(0)), String.valueOf(list.get(list.size()-1))};

        return list;   
    }

    private Iterable<Data> findByCountry(String country) {
        return dataRepository.findByCountry(country);
    }
    
    
    
    @GetMapping(path="i/{indexes}")
    public @ResponseBody Iterable<String> getCountries(@PathVariable String indexes) {
        HashSet<String> tempIds = new HashSet<String>();
        HashSet<String> tempCountries = new HashSet<String>();

        ids.clear();
        years.clear();
        countries.clear();


        int indexCounter = 0;
        for (String index : indexes.split("-")) {
            for (String result : findByIndex(index)) {
                String[] splittedResult = result.split(",");
                String id = splittedResult[0];
                String country = splittedResult[1];
                if (indexCounter == 0) {
                    ids.add(id);
                    countries.add(country);
                }
                else {
                    tempIds.add(id);
                    tempCountries.add(country);
                }
            }
            if (indexCounter >= 1) {
                ids.retainAll(tempIds);
                countries.retainAll(tempCountries);
                tempIds.clear();
                tempCountries.clear();
            }
            indexCounter += 1;
        }
        List<String> list = new ArrayList<String>(countries);
        Collections.sort(list);

        return list;
    }

    private Iterable<String> findByIndex(String index) {
        if (index.equals("CoalConsumption")) {
            return dataRepository.coalConsumptionTotalCountryQuery();
        }
        else if (index.equals("ElectricityGeneration")) {
            return dataRepository.electricityGenerationTotalCountryQuery();
        }
        else if (index.equals("EnergyProduction")) {
            return dataRepository.energyProductionTotalQuery();
        }
        else if (index.equals("HydroPowerGeneration")) {
            return dataRepository.hydroPowerGenerationTotalQuery();
        }
        else if (index.equals("NaturalGasProduction")) {
            return dataRepository.naturalGasProductionTotalQuery();
        }
        else if (index.equals("NaturalGasProvedReserves")) {
            return dataRepository.naturalGasProvedReservesTotalQuery();
        }
        else if (index.equals("NuclearPowerGeneration")) {
            return dataRepository.nuclearPowerGenerationTotalQuery();
        }
        else if (index.equals("OilConsumption")) {
            return dataRepository.oilConsumptionTotalQuery();
        }
        else if (index.equals("OilProduction")) {
            return dataRepository.oilProductionTotalQuery();
        }
        else if (index.equals("OilProvedReserves")) {
            return dataRepository.oilProvedReservesTotalQuery();
        }
        else if (index.equals("ResidentialElectricityUse")) {
            return dataRepository.residentialElectricityUseTotalQuery();
        }
        else if (index.equals("HappinessScore")) {
            return dataRepository.hapiscoreWhrQuery();
        }
        else if (index.equals("HumanDevelopmentIndex")) {
            return dataRepository.hdiHumanDevelopmentIndexQuery();
        }
        else if (index.equals("GDP")) {
            return dataRepository.incomePerPersonGdppercapitaPppInflationAdjustedQuery();
        }
        else if (index.equals("InequalityIndexGini")) {
            return dataRepository.inequalityIndexGiniQuery();
        }
        else if (index.equals("TotalPopulation")) {
            return dataRepository.populationTotalQuery();
        }
        else {
            return null;
        }
    }
}
